package com.suresofttech.car.provautosar.core.main;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.Namespace;
import org.dom4j.Node;
import org.dom4j.QName;
import org.dom4j.io.SAXReader;

public class Ex {

    public static void main(String[] args)
    {
        Ex tm = new Ex();
        tm.run();
    }

    public void run()
    {
    	ArrayList EntireFilepath = new ArrayList<>();	//검사하려는 arxml 파일들의 경로를 담고 있는 리스트
    	String odinPath = "C:\\Users\\슈어_공용\\Downloads\\3.분석대상파일";
			
			
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Configuration\\System\\Swcd_Bsw"));
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Generated\\Bsw_Output\\swcd"));
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Generated\\Bsw_Output\\bswmd"));
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Configuration\\System\\Swcd_App"));
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Configuration\\System\\Bswmd"));
			EntireFilepath.addAll(GetEachFilepathList(odinPath + "\\Configuration\\System\\Composition"));
			
			/*Iterator iter = EntireFilepath.iterator();
					while(iter.hasNext()){
						String a = ((File) iter.next()).getPath();
						System.out.println(a);
					}*/
			//GetSwcRunnableShortNameList(EntireFilepath);
			//GetSwcRunnableList(EntireFilepath);
			//GetBswRunnableShortNameList(EntireFilepath);
			/*GetSwcRunnableMap(EntireFilepath);
			System.out.println("");
			GetBswRunnableMap(EntireFilepath);
			System.out.println("");*/
			GetTaskRunnableMap(EntireFilepath);
			//GetSwcRunnableApplicationShortNameList(EntireFilepath);
			//GetSwcBswRunnableMap(EntireFilepath);
			//GetTaskSwcRelationMap();
			//GetBswRunnableMap(EntireFilepath);
			
			
			
    }
    /**
     * Task와 Runnable의 관계를 매핑한 맵을 반환하는 함수(Key : Task 이름, Value : Runnable 이름)
     * @param list
     * @return
     */
    public static Map GetTaskRunnableMap(ArrayList list){
    	Map<String,ArrayList> TaskRunnableMap = new HashMap<String,ArrayList>();	//Task와 Runnable 관계를 나타낸 맵(최종적으로 반환할 맵)
    	Map<String,ArrayList> TaskSwcRelationMap = GetTaskSwcRelationMap();		//
    	Map<String,ArrayList> SwcBswRunnableMap = GetSwcBswRunnableMap(list);
    	
    	Iterator Taskiter = TaskSwcRelationMap.keySet().iterator();
    	while(Taskiter.hasNext()){
    		String TaskName = (String) Taskiter.next();
    		ArrayList<String> SwcNameList = TaskSwcRelationMap.get(TaskName);
    		ArrayList<String> Box = new ArrayList<>();	//TaskRunnableMap의 Value값으로 Put할 때 사용하는 임시 리스트
    		
    		for(String T : SwcNameList){
    			//ArrayList<String> Box = new ArrayList<>();	//TaskRunnableMap의 Value값으로 Put할 때 사용하는 임시 리스트
    			Iterator Swciter = SwcBswRunnableMap.keySet().iterator();
    			while(Swciter.hasNext()){
    				String SwcName = (String) Swciter.next();
    				ArrayList<String> RunnableList = SwcBswRunnableMap.get(SwcName);
    				if(T.equals(SwcName)){
    					for(String R : RunnableList){
    						Box.add(R);
    					}
    				}
    			}
    		}
    		TaskRunnableMap.put(TaskName, Box);
    	}
    	for ( String key : TaskRunnableMap.keySet() ) {
	    System.out.println("Task 이름 : " + key +" || Runnable 이름 : " + TaskRunnableMap.get(key));
		}
    	return TaskRunnableMap;
    }
    
  //Swc와 Bsw와 Runnable의 관계를 나타낸 Map을 반환
    public static Map GetSwcBswRunnableMap(ArrayList list){
    	Map<String,ArrayList> SwcBswRunnableMap = new HashMap<String,ArrayList>();
    	Map<String,ArrayList> SwcRunnableMap = GetSwcRunnableMap(list);
    	Map<String,ArrayList> BswRunnableMap = GetBswRunnableMap(list);
    	ArrayList<String> Duplicated = new ArrayList<>();
    	SwcBswRunnableMap.putAll(SwcRunnableMap);
    	
    	//SwcRunnableMap과 BswRunnableMap의 같은 Key 중 다른 Value값들이 존재함. 그대로 putAll을 하게 된다면 일부 Value값들이 덮어써져서 사라지기 때문에 직접 검사해서 넣는식으로 메서드를 구성
    	Iterator iter = SwcRunnableMap.keySet().iterator();
    	while(iter.hasNext()){
    		String SwcName = (String) iter.next();
    		for(String T : BswRunnableMap.keySet()){
    			if(T.equals(SwcName)){
    				Duplicated.add(T);
    				ArrayList Box = new ArrayList<>();
    				ArrayList SwcRunnableList = SwcRunnableMap.get(SwcName);
    				Box.addAll(SwcRunnableList);
    				ArrayList BswRunnableList = BswRunnableMap.get(T);
    				Box.addAll(BswRunnableList);
    				ArrayList uniqueBox = new ArrayList(new HashSet<>(Box));
    				SwcBswRunnableMap.put(T, uniqueBox);
    			}
    			else{
    				if(!Duplicated.contains(T)){
    					ArrayList Box0 = BswRunnableMap.get(T);
    					SwcBswRunnableMap.put(T, Box0);
    				}
    			}
    		}
    	}
    	
    	//Map 프린팅해보기
    	/*for ( String key : SwcBswRunnableMap.keySet() ) {
    	    System.out.println("Swc 이름 : " + key +" || Runnable 이름 : " + SwcBswRunnableMap.get(key));
    	}*/
    	
    	return SwcBswRunnableMap;
    }
    
  //Bsw와 Runnable의 관계를 나타낸 Map을 반환
    public static Map GetBswRunnableMap(ArrayList list){
    	Map<String,ArrayList> BswRunnableMap = new HashMap<String,ArrayList>();
    	
    	ArrayList<ArrayList> SwcList = GetSwcList();
    	ArrayList<ArrayList> BswRunnableShortNameList = GetBswRunnableShortNameList(list);
    	
    	Iterator iter = SwcList.iterator();
    	while(iter.hasNext()){
    		String SwcName = (String) ((ArrayList) iter.next()).get(0);
    		String ModifySwcName = "";
    		String AutosarModifySwcName = "";		//EcuM_MainFunction, EcuM_LoopDetection의 SHORT-NAME이 BSW_** 형식을 따르는게 아니라 AUTOSAR_** 형식을 따르고 있음. 이 예외를 처리하기 위해 설정
    		//String ModifySwcName = ""; 
    		ArrayList Box = new ArrayList<>();
    		
    		if(SwcName.contains("SwcInstance_"))
    			continue;
    		
    		if(SwcName.contains("BswInstance_")){
    			ModifySwcName = SwcName.replace("BswInstance_","Bsw_");
    			AutosarModifySwcName = SwcName.replace("BswInstance_", "AUTOSAR_");
    		}
    		
    		for(ArrayList T : BswRunnableShortNameList){
    			String LowercaseModifySwcName = ModifySwcName.toLowerCase();
    			String LowercaseAutosarModifySwcName = AutosarModifySwcName.toLowerCase();
    			String LowercaseShortName = ((String) T.get(1)).toLowerCase();
    			if(LowercaseShortName.equals(LowercaseModifySwcName) || LowercaseShortName.equals(LowercaseAutosarModifySwcName)){
    				Box.add(T.get(0));
    			}
    		}
    		
    		if(Box.size()!=0)
    			BswRunnableMap.put(SwcName,Box);
    		else 
    			continue;
    	}
    	/*for ( String key : BswRunnableMap.keySet() ) {
    	    System.out.println("Swc 이름 : " + key +" || Runnable 이름 : " + BswRunnableMap.get(key));
    	}*/
    	return BswRunnableMap;
    }
    
    //Swc와 Runnable의 관계를 나타낸 Map을 반환
    public static Map GetSwcRunnableMap(ArrayList list){
    	Map<String,ArrayList> SwcRunnableMap = new HashMap<String,ArrayList>();
    	
    	ArrayList<ArrayList> SwcList = GetSwcList();
    	ArrayList<ArrayList> SwcRunnableShortNameList = GetSwcRunnableShortNameList(list);
    	
    	Iterator iter = SwcList.iterator();
    	while(iter.hasNext()){
    		String SwcName = (String) ((ArrayList) iter.next()).get(0);
    		String LowercaseSwcName = SwcName.toLowerCase();
    		//String ModifySwcName = ""; 
    		ArrayList Box = new ArrayList<>();
    		
    		/*if(SwcName.contains("SwcInstance_"))
    			ModifySwcName = SwcName.replace("SwcInstance_","");
    		
    		if(SwcName.contains("BswInstance_"))
    			ModifySwcName = SwcName.replace("BswInstance_","");*/
    		
    		for(ArrayList T : SwcRunnableShortNameList){
    			String LowercaseShortName = ((String)T.get(1)).toLowerCase();
    			if(LowercaseSwcName.contains(LowercaseShortName)){
    				Box.add(T.get(0));
    			}
    		}
    		if(Box.size()!=0)
    			SwcRunnableMap.put(SwcName,Box);
    		else 
    			continue;
    	}
    	/*for ( String key : SwcRunnableMap.keySet() ) {
    	    System.out.println("Swc 이름 : " + key +" || Runnable 이름 : " + SwcRunnableMap.get(key));
    	}*/
    	return SwcRunnableMap;
    }
   
  //Bsw Runnable 이름과 그에 따른 APPLICATION SHORT-NAME을 가지고 있는 리스트를 반환
    public static ArrayList GetBswRunnableShortNameList(ArrayList list){
    	ArrayList<ArrayList> BswRunnableShortNameList = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		ArrayList<ArrayList> BswRunnableList = new ArrayList<ArrayList>();
        	ArrayList<ArrayList> BswShortNameList = new ArrayList<ArrayList>();

        	ArrayList BswShortNameNodeList = null;
        	ArrayList BswRunnableNodeList = null;
        	
        	//File 배열에 들어있는 경로를 String으로 변환함
        	String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			
    			BswRunnableNodeList = (ArrayList) doc.selectNodes("//ELEMENTS/BSW-MODULE-ENTRY/SHORT-NAME");
    			 for (int i = 0; i < BswRunnableNodeList.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) BswRunnableNodeList.get(i);
    		            String NameofRunnable = el.getText();
    		            String PathofRunnable = el.getPath();
    		            String UniquePathofRunnable = el.getUniquePath();
    		            
    		            Box.add(NameofRunnable);
    		            Box.add(UniquePathofRunnable);
    		            //System.out.println(Box);
    		            BswRunnableList.add(Box);
    		     }
    			 
    			 BswShortNameNodeList = (ArrayList) doc.selectNodes("//AUTOSAR/AR-PACKAGES/AR-PACKAGE/SHORT-NAME");
        			 for (int i = 0; i < BswShortNameNodeList.size(); i++){
      				 	//임시 리스트
      		        	ArrayList Box = new ArrayList();
      		        	
      		        	Element el = (Element) BswShortNameNodeList.get(i);
      		            String NameofApplicationShortName = el.getText();
      		            String PathofApplicationShortName = el.getPath();
      		            String UniquePathofApplicationShortName = el.getUniquePath();
      		            
      		            Box.add(NameofApplicationShortName);
      		            Box.add(UniquePathofApplicationShortName);
      		            //System.out.println(Box);
      		          BswShortNameList.add(Box);
        			 }
        		
    		    	//Runnable 이름을 Swc APPLICATION-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 연관시키는 과정
    		    	for(ArrayList T : BswShortNameList){
    		    		String Sname = (String) T.get(0);
    		    		String Spath = ((String) T.get(1)).replace("SHORT-NAME","");
    		    		for(ArrayList G : BswRunnableList){
    		    			ArrayList Box = new ArrayList<>();
    		    			String Rname = (String) G.get(0);
    		    			String Rpath = (String) G.get(1);
    		    			
    		    			//EcuM_MainFunction, EcuM_LoopDetection의 SHORT-NAME이 BSW_** 형식을 따르는게 아니라 AUTOSAR_** 형식을 따르고 있음. 이 예외를 처리하기 위해 설정
    		    			if((Rpath.contains(Spath) && Sname.contains("Bsw")) || (Rpath.contains(Spath) && Sname.contains("AUTOSAR"))){
    		    				Box.add(Rname);
    		    				Box.add(Sname);
    		    				BswRunnableShortNameList.add(Box);
    		    			}
    		    		}
    		    	}	 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		
    		doc = null;
    		
    	}
    	
    	//EcuM_MainFunction, EcuM_LoopDetection의 SHORT-NAME이 중복으로 2개 들어가 있어서 중복이 제거된 ArrayList를 반환
    	ArrayList<ArrayList> FinalBswRunnableShortNameList = new ArrayList<ArrayList>(new HashSet<ArrayList>(BswRunnableShortNameList));
    	/*for(int i=0;i<FinalBswRunnableShortNameList.size();i++){
    		ArrayList test = FinalBswRunnableShortNameList.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || SHORT-NAME 이름 : "+test.get(1));
    	}*/
    	
    	return FinalBswRunnableShortNameList;
    }
    
  //Swc Runnable 이름과 그에 따른 SHORT-NAME을 가지고 있는 리스트를 반환
    public static ArrayList GetSwcRunnableShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcRunnableServiceShortNameList = GetSwcRunnableServiceShortNameList(list);
    	ArrayList<ArrayList> SwcRunnableApplicationShortNameList = GetSwcRunnableApplicationShortNameList(list);
    	
    	ArrayList<ArrayList> SwcRunnableShortNameList = new ArrayList<ArrayList>();
    	SwcRunnableShortNameList.addAll(SwcRunnableServiceShortNameList);
    	SwcRunnableShortNameList.addAll(SwcRunnableApplicationShortNameList);

    	return SwcRunnableShortNameList;
    }
    
    //Swc Runnable 이름과 그에 따른 APPLICATION SHORT-NAME을 가지고 있는 리스트를 반환
    public static ArrayList GetSwcRunnableApplicationShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcRunnableApplicationShortNameList = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		ArrayList<ArrayList> RunnableList = new ArrayList<ArrayList>();
        	ArrayList<ArrayList> ApplicationShortNameList = new ArrayList<ArrayList>();

        	ArrayList ApplicationShortNameNodeList = null;
        	ArrayList RunnableNodeList = null;
        	
        	//File 배열에 들어있는 경로를 String으로 변환함
        	String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			
    			RunnableNodeList = (ArrayList) doc.selectNodes("//RUNNABLES/RUNNABLE-ENTITY/SYMBOL");
    			 for (int i = 0; i < RunnableNodeList.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) RunnableNodeList.get(i);
    		            String NameofRunnable = el.getText();
    		            String PathofRunnable = el.getPath();
    		            String UniquePathofRunnable = el.getUniquePath();
    		            
    		            Box.add(NameofRunnable);
    		            Box.add(UniquePathofRunnable);
    		            //System.out.println(Box);
    		            RunnableList.add(Box);
    		     }
    			
    				 ApplicationShortNameNodeList = (ArrayList) doc.selectNodes("//ELEMENTS/APPLICATION-SW-COMPONENT-TYPE/SHORT-NAME");
        			 for (int i = 0; i < ApplicationShortNameNodeList.size(); i++){
      				 	//임시 리스트
      		        	ArrayList Box = new ArrayList();
      		        	
      		        	Element el = (Element) ApplicationShortNameNodeList.get(i);
      		            String NameofApplicationShortName = el.getText();
      		            String PathofApplicationShortName = el.getPath();
      		            String UniquePathofApplicationShortName = el.getUniquePath();
      		            
      		            Box.add(NameofApplicationShortName);
      		            Box.add(UniquePathofApplicationShortName);
      		            //System.out.println(Box);
      		          ApplicationShortNameList.add(Box);
        			 }
        		
    		    	//Runnable 이름을 Swc APPLICATION-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 연관시키는 과정
    		    	for(ArrayList T : ApplicationShortNameList){
    		    		String Sname = (String) T.get(0);
    		    		String Spath = ((String) T.get(1)).replace("SHORT-NAME","");
    		    		for(ArrayList G : RunnableList){
    		    			ArrayList Box = new ArrayList<>();
    		    			String Rname = (String) G.get(0);
    		    			String Rpath = (String) G.get(1);
    		    			if(Rpath.contains(Spath)){
    		    				Box.add(Rname);
    		    				Box.add(Sname);
    		    				SwcRunnableApplicationShortNameList.add(Box);
    		    			}
    		    		}
    		    	}	 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		
    		doc = null;
    		
    	}
    	
    	/*for(int i=0;i<SwcRunnableApplicationShortNameList.size();i++){
    		ArrayList test = SwcRunnableApplicationShortNameList.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || SHORT-NAME 이름 : "+test.get(1));
    	}*/
    	return SwcRunnableApplicationShortNameList;
    }
    
  //Swc Runnable 이름과 그에 따른 SERVICE SHORT-NAME을 가지고 있는 리스트를 반환
    public static ArrayList GetSwcRunnableServiceShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcRunnableServiceShortNameList = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		ArrayList<ArrayList> RunnableList = new ArrayList<ArrayList>();
        	ArrayList<ArrayList> ServiceShortNameList = new ArrayList<ArrayList>();

        	ArrayList ServiceShortNameNodeList = null;
        	ArrayList RunnableNodeList = null;
        	
        	//File 배열에 들어있는 경로를 String으로 변환함
        	String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			
    			RunnableNodeList = (ArrayList) doc.selectNodes("//RUNNABLES/RUNNABLE-ENTITY/SYMBOL");
    			 for (int i = 0; i < RunnableNodeList.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) RunnableNodeList.get(i);
    		            String NameofRunnable = el.getText();
    		            String PathofRunnable = el.getPath();
    		            String UniquePathofRunnable = el.getUniquePath();
    		            
    		            Box.add(NameofRunnable);
    		            Box.add(UniquePathofRunnable);
    		            //System.out.println(Box);
    		            RunnableList.add(Box);
    		     }
    			
    				 ServiceShortNameNodeList = (ArrayList) doc.selectNodes("//ELEMENTS/SERVICE-SW-COMPONENT-TYPE/SHORT-NAME");
        			 for (int i = 0; i < ServiceShortNameNodeList.size(); i++){
     				 	//임시 리스트
     		        	ArrayList Box = new ArrayList();
     		        	Element el = (Element) ServiceShortNameNodeList.get(i);
     		            String NameofServiceShortName = el.getText();
     		            String PathofServiceShortName  = el.getPath();
     		            String UniquePathofServiceShortName  = el.getUniquePath();
     		           
     		            Box.add(NameofServiceShortName);
     		            Box.add(UniquePathofServiceShortName);
     		            //System.out.println(Box);
     		           ServiceShortNameList.add(Box);
        			 }
    			 
    			//Runnable 이름을 Swc SERVICE-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 연관시키는 과정
    		    	for(ArrayList T : ServiceShortNameList){
    		    		String Sname = (String) T.get(0);
    		    		String Spath = ((String) T.get(1)).replace("SHORT-NAME","");
    		    		for(ArrayList G : RunnableList){
    		    			ArrayList Box = new ArrayList<>();
    		    			String Rname = (String) G.get(0);
    		    			String Rpath = (String) G.get(1);
    		    			if(Rpath.contains(Spath)){
    		    				Box.add(Rname);
    		    				Box.add(Sname);
    		    				SwcRunnableServiceShortNameList.add(Box);
    		    			}
    		    		}
    		    	}
    		    		 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	
    	/*for(int i=0;i<SwcRunnableServiceShortNameList.size();i++){
    		ArrayList test = SwcRunnableServiceShortNameList.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || SHORT-NAME 이름 : "+test.get(1));
    	}*/
    	
    	return SwcRunnableServiceShortNameList;
    }
    
    /*Swc Runnable 이름과 Ecud_Rte.arxml 파일에 연관지을 수 있는 SHORT-NAME을 담고 있는 리스트 반환 (파일 하나를 일일이 검사하는게 아니라, 
    		파일 전체에서 뽑아 진행하였는데, 다른 파일인데 겹쳐지는 경로 때문에 잘못된 매핑이 일어나는 오류가 발생) */
   /* public static ArrayList GetSwcRunnableShortNameRelationList(ArrayList list){
    	ArrayList<ArrayList> SwcShortnameRelationList = new ArrayList<ArrayList>();
    	
    	ArrayList<ArrayList> SwcRunnableList = GetSwcRunnableList(list);
    	ArrayList<ArrayList> SwcServiceShortNameList = GetSwcServiceShortNameList(list);
    	ArrayList<ArrayList> SwcApplicationServiceShortNameList = GetSwcApplicationShortNameList(list);
    	
    	//Runnable 이름을 Swc SERVICE-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 연관시키는 과정
    	for(ArrayList T : SwcServiceShortNameList){
    		String Sname = (String) T.get(0);
    		String Spath = ((String) T.get(1)).replace("SHORT-NAME","");
    		for(ArrayList G : SwcRunnableList){
    			ArrayList Box = new ArrayList<>();
    			String Rname = (String) G.get(0);
    			String Rpath = (String) G.get(1);
    			if(Rpath.contains(Spath)){
    				Box.add(Rname);
    				Box.add(Sname);
    				SwcShortnameRelationList.add(Box);
    			}
    			
    		}
    	}
    	
    	//Runnable 이름을 Swc APPLICATION-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 연관시키는 과정
    	for(ArrayList T : SwcApplicationServiceShortNameList){
    		String Sname = (String) T.get(0);
    		String Spath = ((String) T.get(1)).replace("SHORT-NAME","");
    		for(ArrayList G : SwcRunnableList){
    			ArrayList Box = new ArrayList<>();
    			String Rname = (String) G.get(0);
    			String Rpath = (String) G.get(1);
    			if(Rpath.contains(Spath)){
    				Box.add(Rname);
    				Box.add(Sname);
    				SwcShortnameRelationList.add(Box);
    			}
    			
    		}
    	}
    	
    	for(int i=0;i<SwcShortnameRelationList.size();i++){
    		ArrayList test = SwcShortnameRelationList.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || SHORT-NAME 이름 : "+test.get(1));
		 }
    	return SwcShortnameRelationList;
    }*/
    
  //Swc COMPOSITION-SW-COMPONENT-TYPE SHORT-NAME 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetSwcCompositionShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcShortNamePathRelationlist = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		//File 배열에 들어있는 경로를 String으로 변환함
    		String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			 ArrayList nodelist = (ArrayList) doc.selectNodes("//ELEMENTS/COMPOSITION-SW-COMPONENT-TYPE/COMPONENTS/SW-COMPONENT-PROTOTYPE/SHORT-NAME");
    			 for (int i = 0; i < nodelist.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) nodelist.get(i);
    		            String NameofSwcShortname = el.getText();
    		            String PathofSwcShortname= el.getPath();
    		            String UniquePathofSwcShortname = el.getUniquePath();
    		            
    		            Box.add(NameofSwcShortname);
    		            Box.add(UniquePathofSwcShortname);
    		            //System.out.println(Box);
    		            SwcShortNamePathRelationlist.add(Box);
    		       }
    			 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	/*for(int i=0;i<SwcShortNamePathRelationlist.size();i++){
    		ArrayList test = SwcShortNamePathRelationlist.get(i);
				System.out.println("SHORT-NAME 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
    	
    	return SwcShortNamePathRelationlist;
    }
    
    //Swc APPLICATION-SW-COMPONENT-TYPE SHORT-NAME 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetSwcApplicationShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcShortNamePathRelationlist = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		//File 배열에 들어있는 경로를 String으로 변환함
    		String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			 ArrayList nodelist = (ArrayList) doc.selectNodes("//ELEMENTS/APPLICATION-SW-COMPONENT-TYPE/SHORT-NAME");
    			 for (int i = 0; i < nodelist.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) nodelist.get(i);
    		            String NameofSwcShortname = el.getText();
    		            String PathofSwcShortname = el.getPath();
    		            String UniquePathofSwcShortname = el.getUniquePath();
    		            
    		            Box.add(NameofSwcShortname);
    		            Box.add(UniquePathofSwcShortname);
    		            //System.out.println(Box);
    		            SwcShortNamePathRelationlist.add(Box);
    		       }
    			 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	for(int i=0;i<SwcShortNamePathRelationlist.size();i++){
    		ArrayList test = SwcShortNamePathRelationlist.get(i);
				System.out.println("SHORT-NAME 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }
    	
    	return SwcShortNamePathRelationlist;
    }
    
  //Swc SERVICE-SW-COMPONENT-TYPE의 SHORT-NAME 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetSwcServiceShortNameList(ArrayList list){
    	ArrayList<ArrayList> SwcShortNamePathRelationlist = new ArrayList<ArrayList>();
    	Iterator iter = list.iterator();
    	
    	while(iter.hasNext()){
    		//File 배열에 들어있는 경로를 String으로 변환함
    		String StringFilepath = ((File) iter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			 ArrayList nodelist = (ArrayList) doc.selectNodes("//ELEMENTS/SERVICE-SW-COMPONENT-TYPE/SHORT-NAME");
    			 for (int i = 0; i < nodelist.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) nodelist.get(i);
    		            String NameofSwcShortname = el.getText();
    		            String PathofSwcRunnable = el.getPath();
    		            String UniquePathofSwcShortname = el.getUniquePath();
    		            
    		            Box.add(NameofSwcShortname);
    		            Box.add(UniquePathofSwcShortname);
    		            //System.out.println(Box);
    		            SwcShortNamePathRelationlist.add(Box);
    		       }
    			 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	/*for(int i=0;i<SwcShortNamePathRelationlist.size();i++){
    		ArrayList test = SwcShortNamePathRelationlist.get(i);
				System.out.println("SHORT-NAME 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
    	
    	return SwcShortNamePathRelationlist;
    }
    
  //Swc,Bsw Runnable 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetSwcBswRunnableList(ArrayList list){
    	ArrayList<ArrayList> SwcBswRunnablePathRelationlist = new ArrayList<ArrayList>();
    	ArrayList<ArrayList> BswRunnablePathRelationlist = GetBswRunnableList(list);
    	ArrayList<ArrayList> SwcRunnablePathRelationlist = GetSwcRunnableList(list);
    	
    	Iterator i = SwcRunnablePathRelationlist.iterator();
		while(i.hasNext()){
			ArrayList Box = (ArrayList) i.next();
			SwcBswRunnablePathRelationlist.add(Box);
		}
		
		Iterator j = BswRunnablePathRelationlist.iterator();
		while(j.hasNext()){
			ArrayList Box = (ArrayList) j.next();
			SwcBswRunnablePathRelationlist.add(Box);
		}
		
		Iterator iter = SwcBswRunnablePathRelationlist.iterator();
		while(iter.hasNext()){
			System.out.println((ArrayList)iter.next());
		}
    	
    	return SwcBswRunnablePathRelationlist;
    }
   
  //Bsw Runnable 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetBswRunnableList(ArrayList list){
    	ArrayList<ArrayList> BswRunnablePathRelationlist = new ArrayList<ArrayList>();
    	Iterator pathiter = list.iterator();
    	
    	while(pathiter.hasNext()){
    		//File 배열에 들어있는 경로를 String으로 변환함
    		String StringFilepath = ((File) pathiter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			 ArrayList nodelist = (ArrayList) doc.selectNodes("//ELEMENTS/BSW-MODULE-ENTRY/SHORT-NAME");
    			 for (int i = 0; i < nodelist.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) nodelist.get(i);
    		            String NameofBswRunnable = el.getText();
    		            String PathofBswRunnable = el.getPath();
    		            String UniquePathofBswRunnable = el.getUniquePath();
    		            
    		            Box.add(NameofBswRunnable);
    		            Box.add(UniquePathofBswRunnable);
    		            //System.out.println(Box);
    		            BswRunnablePathRelationlist.add(Box);
    		       }
    			 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	/*for(int i=0;i<BswRunnablePathRelationlist.size();i++){
    		ArrayList test = BswRunnablePathRelationlist.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
    	
    	return BswRunnablePathRelationlist;
    }
    
  
    
    //Swc Runnable 이름과 그에 따른 경로를 가지고 있는 리스트를 반환
    public static ArrayList GetSwcRunnableList(ArrayList list){
    	ArrayList<ArrayList> SwcRunnablePathRelationlist = new ArrayList<ArrayList>();
    	Iterator pathiter = list.iterator();
    	
    	while(pathiter.hasNext()){
    		//File 배열에 들어있는 경로를 String으로 변환함
    		String StringFilepath = ((File) pathiter.next()).getPath();
    		File file = new File(StringFilepath);
    		SAXReader reader = new SAXReader();
    		Document doc;
    		try{
    			doc = reader.read(file);
    			removeAllNamespaces(doc);
    			 ArrayList nodelist = (ArrayList) doc.selectNodes("//RUNNABLES/RUNNABLE-ENTITY/SYMBOL");
    			 for (int i = 0; i < nodelist.size(); i++){
    				 	//임시 리스트
    		        	ArrayList Box = new ArrayList();
    		        	Element el = (Element) nodelist.get(i);
    		            String NameofSwcRunnable = el.getText();
    		            String PathofSwcRunnable = el.getPath();
    		            String UniquePathofSwcRunnable = el.getUniquePath();
    		            
    		            Box.add(NameofSwcRunnable);
    		            Box.add(UniquePathofSwcRunnable);
    		            //System.out.println(Box);
    		            SwcRunnablePathRelationlist.add(Box);
    		       }
    			 
    		}catch(DocumentException e){
    			e.printStackTrace();
    		}catch(ClassCastException e){
    			continue;
    		}
    		doc = null;
    	}
    	/*for(int i=0;i<SwcRunnablePathRelationlist.size();i++){
    		ArrayList test = SwcRunnablePathRelationlist.get(i);
				System.out.println("Runnable 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
    	
    	return SwcRunnablePathRelationlist;
    }
    
    //filepath 경로 폴더내에 존재하는 모든 파일을 담은 리스트를 반환하는 함수
    public static ArrayList GetEachFilepathList(String filepath){
    	File file = new File(filepath);
    	SAXReader reader = new SAXReader();
    	Document doc;
    	ArrayList Fpath = new ArrayList<>();
    	try {
    		for(File f : file.listFiles()) {
				doc = reader.read(f);
				removeAllNamespaces(doc);
				Fpath.add(f);
			}
		} catch (DocumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	doc = null;
    	return Fpath;
    }
    
    public static ArrayList<ArrayList> GetSwcList(){
    	ArrayList<ArrayList> SwcList = new ArrayList<ArrayList>();
    	String filePath = ".\\templates\\Ecud_Rte.arxml";
    	File file = new File(filePath);
		SAXReader reader = new SAXReader();
    	Document doc;
    	try {
    		doc = reader.read(file);
			removeAllNamespaces(doc);
    		ArrayList<ArrayList> listOfSwc = getSwcNodeList(doc,"//CONTAINERS/ECUC-CONTAINER-VALUE/SHORT-NAME");
    		SwcList = listOfSwc;
    	} catch (DocumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	/*for(int i=0;i<SwcList.size();i++){
    		ArrayList test = SwcList.get(i);
				System.out.println("Swc 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
    	
    	return SwcList;
    }
    //Task-Swc 관계를 담은 맵을 반환
    public static Map GetTaskSwcRelationMap(){
    	Map<String,ArrayList> FinalTaskSwcRelationmap = new HashMap<String,ArrayList>();
    	String filePath = ".\\templates\\Ecud_Rte.arxml";
    	File file = new File(filePath);
		SAXReader reader = new SAXReader();
    	Document doc;
    	try {
			doc = reader.read(file);
			removeAllNamespaces(doc);
    	Map<String,ArrayList> TaskSwcRelationmap = new HashMap<String,ArrayList>();
    	Map<String,ArrayList> TaskPathRelationmap = getTaskNodeMap(doc,"//ECUC-REFERENCE-VALUE/VALUE-REF");
    	ArrayList<ArrayList> listOfSwc = getSwcNodeList(doc,"//CONTAINERS/ECUC-CONTAINER-VALUE/SHORT-NAME");
    	ArrayList<ArrayList> listOfTask = getTaskNodeList(doc,"//ECUC-REFERENCE-VALUE/VALUE-REF");
		
    	
    	for(String key : TaskPathRelationmap.keySet()){
    		ArrayList pathlistOfTask = new ArrayList();
    		pathlistOfTask = TaskPathRelationmap.get(key);
    		//Task-Swc를 매핑하기 위한 임시 Swc 리스트
    		ArrayList listOfSwcBox = new ArrayList();
    		for(int i =0; i<pathlistOfTask.size();i++){
    			for(int j =0; j<listOfSwc.size();j++){
    				String AllpathOfSwc = (String) listOfSwc.get(j).get(1);
    				String FixpathOfSwc = AllpathOfSwc.replace("SHORT-NAME","");
    				String SwcName = (String) listOfSwc.get(j).get(0);
    				String pathOfTask = (String) pathlistOfTask.get(i);
    				if(pathOfTask.contains(FixpathOfSwc))
    					listOfSwcBox.add(SwcName);
    				
    			}
    			if(i == pathlistOfTask.size()-1)
    				TaskSwcRelationmap.put(key,listOfSwcBox);
    			
    		}
    			
    	}
    	
    	/*//TaskSwcRelationmap의 value값 = 리스트 중에 중복된 값들을 제거하는 작업
    	Iterator iter = TaskSwcRelationmap.keySet().iterator();
    	while(iter.hasNext()){
    		System.out.println(iter.next());
    		ArrayList list = TaskSwcRelationmap.get(iter.next());
    		ArrayList Newlist = new ArrayList(new HashSet(list));
    		//FinalTaskSwcRelationmap.put((String) iter.next(), Newlist);
    	}*/
    	
    	//TaskSwcRelationmap의 value값 = 리스트 중에 중복된 값들을 제거하는 작업
    	for(String key : TaskSwcRelationmap.keySet()){
    		ArrayList list = TaskSwcRelationmap.get(key);
    		ArrayList Newlist = new ArrayList(new HashSet(list));
    		FinalTaskSwcRelationmap.put(key, Newlist);
    	}
    	
    	
    	//Map 프린팅해보기
    	/*for ( String key : FinalTaskSwcRelationmap.keySet() ) {
    	    System.out.println("Taskname : " + key +" || Swcname : " + FinalTaskSwcRelationmap.get(key));
    	}*/
    	
    		
    	} catch (DocumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	doc = null;
    	return FinalTaskSwcRelationmap;
    }
    	
    /**
     * Document에서 Xpath로 결과값  추출
     * @param Document
     * @param Xpath
     * @return
     */
    public static String strGetNodeText(Document doc, String strXpath)
    {
        try {
            Node node = doc.selectSingleNode(strXpath);
            return node.getText();
        } catch (NullPointerException ne) {
            return "";
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }
    
    /**
     * Element에서 Xpath로 결과값  추출
     * @param Element
     * @param Xpath
     * @return
     */
    public static String strGetNodeText(Element el, String strXpath)
    {
        try {
            Node node = el.selectSingleNode(strXpath);
            return node.getText();
        } catch (NullPointerException ne) {
            return "";
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }

    /**
     * ArrayList에 담기 및  모든 Element를 출력
     * @param alList
     */
    public static void doViewAllElement(ArrayList alList)
    {

        for (int i = 0; i < alList.size(); i++)
        {
            Element el = (Element) alList.get(i);
            if (el.getText().length() > 0)
            	 System.out.println(el.getText());
            else
            System.out.println("NAME : " + el.getUniquePath());
        }
        System.out.println();
    }
    
    
    
    //Swc 이름과 해당 경로를 저장하고 있는 리스트를 반환
    public static ArrayList getSwcNodeList(Document doc, String strXpath)
    {
        ArrayList list = (ArrayList) doc.selectNodes(strXpath);
        ArrayList<ArrayList> SwcPathRelationlist = new ArrayList<ArrayList>();
        for (int i = 0; i < list.size(); i++)
        {
        	//임시 리스트
        	ArrayList Box = new ArrayList();
            Element el = (Element) list.get(i);
            String NameofSwc = el.getText();
            String PathofSwc = el.getUniquePath();
            if(NameofSwc.contains("Instance_")){
            	Box.add(NameofSwc);
            	Box.add(PathofSwc);
            	SwcPathRelationlist.add(Box);
            }
        }
        /*for(int i=0;i<SwcPathRelationlist.size();i++){
    		ArrayList test = SwcPathRelationlist.get(i);
				System.out.println("Swc 이름 : "+test.get(0)+" || 경로 : "+test.get(1));
		 }*/
        return SwcPathRelationlist;
    }
    
    /**
     * Task 이름과 해당 경로들을 매핑한 맵을 반환(Key : Task 이름, Value : 경로들)
     * getTaskNodeList()보다 더 직관적임.
     * @param doc
     * @param strXpath
     * @return
     */
    public static Map getTaskNodeMap(Document doc, String strXpath){
    	Map<String,ArrayList> map = new HashMap<String,ArrayList>();	//Task와 해당 경로들을 매핑한 맵(함수에서 최종적으로 반환할 맵)
    	ArrayList list = (ArrayList) doc.selectNodes(strXpath);	//경로 strXpath에 해당하는 노드를 list에 저장 
    	ArrayList<ArrayList> TaskPathRelationlist = getTaskNodeList(doc,strXpath);
    	
        
        //TaskPathRelationlist를 맵으로 변환하는 과정(TaskPathRelationlist의 첫번째 인덱스 : Task이름, 나머지 인덱스 : 다수의 경로들)
        for(int i=0;i<TaskPathRelationlist.size();i++){
        	ArrayList PathListBox = new ArrayList<>();		//Task의 경로들을 담는 ArrayList
        	String Taskname = (String) TaskPathRelationlist.get(i).get(0);
        	
        	//Task의 경로는 리스트의 인덱스 1번부터 이므로 j=1부터 시작하여 경로들을 모두 PathListBox에 담는다.
        	for(int j=1;j<TaskPathRelationlist.get(i).size();j++){
        		PathListBox.add(TaskPathRelationlist.get(i).get(j));
        		
        		//만약 PathListBox에 Task의 경로들을 모두 담았으면 map에 Task이름과 매핑시킨다.
        		if(PathListBox.size() == TaskPathRelationlist.get(i).size()-1)
        			map.put(Taskname, PathListBox);
        	}
        }
        
        //Task와 그에 해당하는 경로들을 매핑한 Map을 반환
    	return map;
    }
    
    /**
     * Document에서 경로 strXpath에 해당되는 모든 노드를 리턴
     * Task 이름과 해당 경로를 저장하고 있는 리스트를 반환(TaskPathRelationlist안에 존재하는 리스트들의 첫번째 인덱스 : Task 이름, 나머지 인덱스 : 다수의 경로들)
     * @param doc
     * @param strXpath
     * @return
     */
    public static ArrayList getTaskNodeList(Document doc, String strXpath)
    {
    	ArrayList list = (ArrayList) doc.selectNodes(strXpath);		//경로 strXpath에 해당하는 노드를 list에 저장 
    	ArrayList<ArrayList> TaskPathRelationlist = new ArrayList<ArrayList>();	//Task 이름과 해당 경로를 저장하고 있는 리스트(TaskPathRelationlist안에 존재하는 리스트들의 첫번째 인덱스 : Task 이름, 나머지 인덱스 : 다수의 경로들)
    	
    	//저장한 list안의 노드에서 Task이름과 경로를 뽑아내는 과정
        for (int i = 0; i < list.size(); i++){
        	ArrayList Box = new ArrayList();	//TaskPathRelationlist 안에 리스트를 넣기 위한 임시 ArrayList 
        	Element el = (Element) list.get(i);	//list안에 있는 노드를 element형태로 변환하여 뽑아냄
        	
        	/*getText()함수를 이용하여 element들의 데이터를 String의 형태로 뽑아냄. Task 이름을 가지고 있는 데이터의 형태는 '/AUTOSAR/Os/OsTask_BSW_FG1_10ms_Sub1'로
        	 *  되어있기 때문에 Task이름만 뽑아내기 위해 substring() 함수를 사용
        	 */
        	String NameofTask = el.getText().substring(12);	
            String PathofTask = el.getUniquePath();	//뽑아낸 데이터의 경로를 뽑아내기 위해 getUniquePath() 함수 사용. getPath()함수는 경로의 배열값까지 상세히 나오지 않음. 따라서 getUniquePath()함수 사용.
            
            //뽑아낸 데이터의 문자열에 OsTask가 포함되어있으면 임시리스트 Box에 추가하고 TaskPathRelationlist에 추가.
            if(NameofTask.contains("OsTask")){
            	Box.add(NameofTask);
            	Box.add(PathofTask);
            	TaskPathRelationlist.add(Box);
            }
        }
        
      /*
       * Task가 여러 Swc를 호출하기 때문에 경로도 여러가지이다. 위에서는 여러가지 경로를 고려하지 않고 바로바로 add 했기 때문에  Task 이름이 각각 다른 경로로 중복되어서 리스트에 따로 존재한다. 
       * ex)[[Task1,경로1],[Task1,경로2]....] 
       * 따라서  여러가지 경로를 하나의 Task 이름에 매핑해줘야 한다. ex)[[Task1,경로1,경로2,...],[Task2,경로4,경로5,...]] 
       */
        for(int i=0; i<TaskPathRelationlist.size();i++){
			ArrayList DuplicatedCheck = new ArrayList<>();	
			DuplicatedCheck = TaskPathRelationlist.get(i);
			for(int j=0; j<TaskPathRelationlist.size();j++){
				if(DuplicatedCheck.get(0).equals(TaskPathRelationlist.get(j).get(0))&& i!=j){
					if(DuplicatedCheck.get(1) != TaskPathRelationlist.get(j).get(1)){
						TaskPathRelationlist.get(i).add(TaskPathRelationlist.get(j).get(1));
						TaskPathRelationlist.remove(j);
						j-=1;
						continue;
					}
				}
			}
		}
        return TaskPathRelationlist;
    }

    /**
     * document에서 xpath에 해당되는 모든 element를 리턴
     * @param doc
     * @param strXpath
     * @return
     */
    public static ArrayList getNodeList(Document doc, String strXpath)
    {
        return (ArrayList) doc.selectNodes(strXpath);
    }
    
    /**
     * element에서 xpath에 해당되는 모든 element를 리턴
     * @param element
     * @param strXpath
     * @return
     */
    public static ArrayList getNodeList(Element element, String strXpath)
    {
        return (ArrayList) element.selectNodes(strXpath);	
    }
    
    /**
     * doc의 Namespace를 제거해주는 함수(Namespace가 존재할 경우 파싱이 재대로 되지 않는 오류가 존재함. 따라서 doc을 불러오고 반드시 Namespace를 제거해주고 파싱작업을 시작해야함)
     * @param doc
     */
    public static void removeAllNamespaces(Document doc) {
        Element root = doc.getRootElement();
        if (root.getNamespace() !=
                Namespace.NO_NAMESPACE) {            
                removeNamespaces(root.content());
        }
    }

    public static void unfixNamespaces(Document doc, Namespace original) {
        Element root = doc.getRootElement();
        if (original != null) {
            setNamespaces(root.content(), original);
        }
    }

    public static void setNamespace(Element elem, Namespace ns) {

        elem.setQName(QName.get(elem.getName(), ns,
                elem.getQualifiedName()));
    }

    /**
     *Recursively removes the namespace of the element and all its
    children: sets to Namespace.NO_NAMESPACE
     */
    public static void removeNamespaces(Element elem) {
        setNamespaces(elem, Namespace.NO_NAMESPACE);
    }

    /**
     *Recursively removes the namespace of the list and all its
    children: sets to Namespace.NO_NAMESPACE
     */
    public static void removeNamespaces(List l) {
        setNamespaces(l, Namespace.NO_NAMESPACE);
    }

    /**
     *Recursively sets the namespace of the element and all its children.
     */
    public static void setNamespaces(Element elem, Namespace ns) {
        setNamespace(elem, ns);
        setNamespaces(elem.content(), ns);
    }

    /**
     *Recursively sets the namespace of the List and all children if the
    current namespace is match
     */
    public static void setNamespaces(List l, Namespace ns) {
        Node n = null;
        for (int i = 0; i < l.size(); i++) {
            n = (Node) l.get(i);

            if (n.getNodeType() == Node.ATTRIBUTE_NODE) {
                ((Attribute) n).setNamespace(ns);
            }
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                setNamespaces((Element) n, ns);
            }            
        }
    }
    
   
    
    
}
